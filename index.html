<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador e Analisador de Redação</title>
    <!-- Inclui o Tailwind CSS via CDN para um estilo moderno e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Caveat:wght@700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* Fundo escuro para um visual mais moderno */
            background-color: #1f2937;
            color: #d1d5db; /* Cor do texto padrão mais clara */
        }
        /* Estilos para a área de carregamento */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Estilo para o gradiente do botão principal */
        .btn-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6);
            transition: all 0.2s ease-in-out;
        }
        .btn-gradient:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }
        /* Estilo para o gradiente do botão secundário */
        .btn-secondary {
            background-image: linear-gradient(to right, #4b5563, #374151);
            transition: all 0.2s ease-in-out;
        }
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(75, 85, 99, 0.4);
        }
        .btn-tertiary {
            background-image: linear-gradient(to right, #10b981, #06b6d4);
            transition: all 0.2s ease-in-out;
        }
        .btn-tertiary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }
        /* Estilo do modal pop-up */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #f3f4f6;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            max-width: 28rem;
            width: 90%;
        }
        .font-caveat {
            font-family: 'Caveat', cursive;
        }
        
        /* Estilos para o conteúdo formatado (dicas e análise) */
        #infoContent strong {
            color: #4f46e5; /* Cor indigo para negritos */
        }
        #infoContent h3 {
            border-bottom: 2px solid #e0e7ff; /* Linha sutil para subtítulos */
            padding-bottom: 0.5rem;
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex items-center justify-center min-h-screen">

    <!-- Tela Inicial (visível por padrão) -->
    <div id="introScreen" class="flex flex-col items-center justify-center text-center p-8 transition-all duration-500">
        <!-- Logotipo -->
        <div class="mb-4">
            <svg class="w-24 h-24 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
            </svg>
        </div>
        <!-- Título em fonte manuscrita foi adicionado aqui -->
        <div class="mb-8 -rotate-3">
            <span class="text-white text-5xl font-caveat font-bold drop-shadow-md">Redação</span>
        </div>
        <button id="startButton" class="text-white font-bold py-4 px-10 rounded-full shadow-lg text-lg btn-gradient">
            Começar
        </button>
    </div>

    <!-- Aplicativo principal (inicialmente escondido) -->
    <div id="mainApp" class="hidden bg-gray-50 p-6 sm:p-10 rounded-[2rem] shadow-2xl max-w-4xl w-full flex flex-col lg:flex-row gap-8 lg:gap-12 transition-all duration-300 relative overflow-hidden">
        
        <!-- Fundo com formas geométricas -->
        <div class="absolute inset-0 z-0">
            <!-- Círculo grande no canto superior esquerdo -->
            <svg class="absolute top-[-100px] left-[-100px] w-[400px] h-[400px] text-indigo-200 opacity-20 filter blur-3xl" fill="currentColor" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <circle cx="100" cy="100" r="100"/>
            </svg>
            <!-- Círculo pequeno no canto inferior direito -->
            <svg class="absolute bottom-[-50px] right-[-50px] w-[200px] h-[200px] text-cyan-200 opacity-20 filter blur-2xl" fill="currentColor" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <circle cx="100" cy="100" r="100"/>
            </svg>
        </div>

        <!-- Seção de Controle e Dicas (Esquerda) -->
        <div class="flex-1 relative z-10">
            <!-- Logotipo para a tela principal -->
            <div class="flex items-center gap-3 mb-4">
                <svg class="w-10 h-10 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                </svg>
            </div>
            <!-- Título e descrição da página principal -->
            <h2 class="text-2xl font-bold text-gray-800 mb-2">Gerador e Analisador de Redação</h2>
            <p class="text-gray-600 mb-6">Utilize as ferramentas abaixo para gerar dicas, criar uma redação do zero ou analisar um texto já escrito no padrão ENEM.</p>

            <!-- Campo de entrada do tema com placeholder -->
            <div class="mb-5">
                <input type="text" id="topicInput" placeholder="Digite o tema da sua redação aqui..." class="w-full px-4 py-3 rounded-xl border-2 border-gray-300 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all duration-200 shadow-sm text-gray-800">
            </div>

            <!-- Botões de ação -->
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
                <button id="generateTipsBtn" class="w-full text-white font-bold py-3 px-6 rounded-xl shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 flex items-center justify-center btn-secondary">
                    <span id="buttonTextTips">Gerar Dicas</span>
                    <div id="loadingSpinnerTips" class="loading-spinner hidden ml-3"></div>
                </button>
                <button id="generateEssayBtn" class="w-full text-white font-bold py-3 px-6 rounded-xl shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 flex items-center justify-center btn-gradient">
                    <span id="buttonTextEssay">Gerar Redação</span>
                    <div id="loadingSpinnerEssay" class="loading-spinner hidden ml-3"></div>
                </button>
                 <button id="analyzeEssayBtn" class="w-full text-white font-bold py-3 px-6 rounded-xl shadow-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-all duration-200 flex items-center justify-center btn-tertiary">
                    <span id="buttonTextAnalyze">Analisar Redação</span>
                    <div id="loadingSpinnerAnalyze" class="loading-spinner hidden ml-3"></div>
                </button>
            </div>

            <!-- Área para exibir as dicas da IA e a análise da redação -->
            <div id="infoContainer" class="mt-8 bg-gray-100 p-6 rounded-2xl shadow-inner transition-all duration-300 border border-gray-300">
                <div id="infoContent" class="text-gray-800 leading-relaxed font-normal"></div>
            </div>
        </div>

        <!-- Área de escrita da redação (Direita) -->
        <div class="flex-1 flex flex-col relative z-10">
            <textarea id="essayEditor" class="flex-1 w-full p-4 rounded-xl border-2 border-gray-300 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all duration-200 text-lg shadow-sm text-gray-800 min-h-96" placeholder="Escreva sua redação aqui ou clique em 'Gerar Redação' para começar..."></textarea>
             <!-- Adiciona o contador de palavras abaixo do editor e o novo botão de limpar -->
            <div class="mt-3 flex justify-between items-center text-sm">
                <button id="clearEssayBtn" class="px-4 py-2 rounded-lg text-gray-700 bg-gray-200 hover:bg-gray-300 transition-all duration-200 font-medium">Limpar Redação</button>
                <span class="text-right text-gray-600">
                    <span id="wordCount" class="font-bold text-red-500">0</span> / 270
                </span>
            </div>
        </div>
    </div>

    <!-- Modal para a senha de administrador -->
    <div id="passwordModal" class="modal hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-bold text-gray-800 mb-4 text-center">Senha de Administrador</h3>
            <p class="text-gray-600 mb-4 text-center">Por favor, insira a senha para gerar a redação.</p>
            <input type="password" id="modalPasswordInput" class="w-full px-4 py-3 rounded-xl border-2 border-gray-300 focus:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all duration-200 shadow-sm text-gray-800 mb-4" placeholder="Senha">
            <p id="passwordError" class="text-red-500 font-medium text-sm mb-4 hidden text-center">Senha incorreta. Tente novamente.</p>
            <div class="flex justify-end gap-3">
                <button id="modalCancelBtn" class="px-6 py-2 rounded-xl text-gray-700 bg-gray-200 hover:bg-gray-300 transition-all duration-200 font-medium">Cancelar</button>
                <button id="modalConfirmBtn" class="px-6 py-2 rounded-xl text-white font-medium btn-gradient">Confirmar</button>
            </div>
        </div>
    </div>

    <script>
        // Configurações da API atualizadas conforme as melhores práticas
        const API_KEY = "AIzaSyDc1PX50gVPrupjm2VMIiojyDYfhee4NEo"; // CHAVE DE API INSERIDA AQUI
        const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025';
        const ADMIN_PASSWORD = 'wpm2025';

        // Referências aos elementos HTML
        const introScreen = document.getElementById('introScreen');
        const mainApp = document.getElementById('mainApp');
        const startButton = document.getElementById('startButton');
        const topicInput = document.getElementById('topicInput');
        const generateTipsBtn = document.getElementById('generateTipsBtn');
        const generateEssayBtn = document.getElementById('generateEssayBtn');
        const analyzeEssayBtn = document.getElementById('analyzeEssayBtn');
        const clearEssayBtn = document.getElementById('clearEssayBtn');
        const infoContainer = document.getElementById('infoContainer');
        const infoContent = document.getElementById('infoContent');
        const essayEditor = document.getElementById('essayEditor');
        const loadingSpinnerTips = document.getElementById('loadingSpinnerTips');
        const buttonTextTips = document.getElementById('buttonTextTips');
        const loadingSpinnerEssay = document.getElementById('loadingSpinnerEssay');
        const buttonTextEssay = document.getElementById('buttonTextEssay');
        const loadingSpinnerAnalyze = document.getElementById('loadingSpinnerAnalyze');
        const buttonTextAnalyze = document.getElementById('buttonTextAnalyze');
        const wordCountSpan = document.getElementById('wordCount');
        
        // Referências aos elementos do modal
        const passwordModal = document.getElementById('passwordModal');
        const modalPasswordInput = document.getElementById('modalPasswordInput');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const passwordError = document.getElementById('passwordError');

        // Adiciona ouvintes de evento
        startButton.addEventListener('click', () => {
            introScreen.classList.add('hidden');
            mainApp.classList.remove('hidden');
        });
        generateTipsBtn.addEventListener('click', generateTips);
        generateEssayBtn.addEventListener('click', openPasswordModal);
        analyzeEssayBtn.addEventListener('click', analyzeEssay);
        essayEditor.addEventListener('input', updateWordCount);
        // Adiciona o ouvinte de evento para o novo botão
        clearEssayBtn.addEventListener('click', () => {
            essayEditor.value = '';
            infoContent.innerHTML = '';
            infoContainer.classList.remove('bg-red-100');
            infoContainer.classList.add('bg-gray-100');
            updateWordCount();
        });

        // Ouvintes de evento do modal
        modalCancelBtn.addEventListener('click', closePasswordModal);
        modalConfirmBtn.addEventListener('click', checkPasswordAndGenerate);
        modalPasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkPasswordAndGenerate();
            }
        });
        
        function openPasswordModal() {
            // Exibe o modal e limpa os campos
            passwordModal.classList.remove('hidden');
            modalPasswordInput.value = '';
            passwordError.classList.add('hidden');
        }

        function closePasswordModal() {
            // Esconde o modal
            passwordModal.classList.add('hidden');
        }

        async function checkPasswordAndGenerate() {
            const password = modalPasswordInput.value;
            if (password === ADMIN_PASSWORD) {
                closePasswordModal();
                await startEssayGeneration();
            } else {
                passwordError.classList.remove('hidden');
            }
        }
        
        function updateWordCount() {
            // Conta as palavras no editor de texto. Remove espaços múltiplos.
            const text = essayEditor.value.trim();
            const words = text ? text.split(/\s+/).filter(word => word.length > 0) : [];
            const count = words.length;
            wordCountSpan.textContent = count;

            // Altera a cor do contador dependendo do número de palavras
            if (count >= 270) {
                wordCountSpan.classList.remove('text-red-500');
                wordCountSpan.classList.add('text-green-500');
            } else {
                wordCountSpan.classList.remove('text-green-500');
                wordCountSpan.classList.add('text-red-500');
            }
        }

        /**
         * Alterna o estado de um botão (habilitado/desabilitado, texto e spinner de carregamento).
         * @param {HTMLElement} button - O elemento do botão.
         * @param {HTMLElement} buttonText - O elemento de texto dentro do botão.
         * @param {HTMLElement} spinner - O elemento do spinner de carregamento.
         * @param {boolean} isLoading - Se o botão deve estar em estado de carregamento.
         * @param {string} defaultText - O texto padrão do botão quando não está carregando.
         */
        function toggleButtonState(button, buttonText, spinner, isLoading, defaultText) {
            button.disabled = isLoading;
            buttonText.textContent = isLoading ? 'Carregando...' : defaultText;
            if (isLoading) {
                spinner.classList.remove('hidden');
            } else {
                spinner.classList.add('hidden');
            }
        }

        async function generateTips() {
            const topic = topicInput.value.trim();
            if (!topic) {
                infoContent.innerHTML = '<span class="text-red-500 font-semibold">Por favor, insira um tema para a redação.</span>';
                infoContainer.classList.remove('bg-gray-100');
                infoContainer.classList.add('bg-red-100');
                return;
            }

            // Desabilita os botões durante a requisição
            toggleButtonState(generateTipsBtn, buttonTextTips, loadingSpinnerTips, true, 'Gerar Dicas');
            toggleButtonState(generateEssayBtn, buttonTextEssay, loadingSpinnerEssay, true, 'Gerar Redação');
            toggleButtonState(analyzeEssayBtn, buttonTextAnalyze, loadingSpinnerAnalyze, true, 'Analisar Redação');
            
            infoContent.textContent = 'Gerando dicas para o tema: ' + topic + '...';
            infoContainer.classList.remove('bg-red-100');
            infoContainer.classList.add('bg-gray-100');

            // Prompt atualizado para focar no formato e nas competências do ENEM
            const prompt = `Gere um guia de planejamento de redação ENEM (nota 600+) para o tema: "${topic}".
A resposta deve ser estruturada em 3 partes, usando Markdown e focando nas competências do ENEM.

1. **Tese e Argumentos (C2 e C3):** Sugira 1 tese clara e 2 eixos argumentativos (um para cada parágrafo de desenvolvimento) que sustentem essa tese.
2. **Repertório Sociocultural (C2):** Sugira 2 a 3 repertórios socioculturais válidos para o tema (como filósofos, sociólogos, filmes, leis, etc.), explicando brevemente como eles se conectam aos argumentos.
3. **Proposta de Intervenção (C5):** Estruture uma Proposta de Intervenção completa (Agente, Ação, Meio, Finalidade e Detalhamento) que resolva o problema central do tema.

Use linguagem motivacional e clara.`;

            await callGeminiApi(prompt, 'tips');
        }

        async function startEssayGeneration() {
            const topic = topicInput.value.trim();

            if (!topic) {
                // Alerta suave para o usuário se o campo de tema estiver vazio
                infoContent.innerHTML = '<span class="text-red-500 font-semibold">Por favor, insira um tema para a redação.</span>';
                infoContainer.classList.remove('bg-gray-100');
                infoContainer.classList.add('bg-red-100');
                return;
            }

            // Desabilita os botões durante a requisição
            toggleButtonState(generateTipsBtn, buttonTextTips, loadingSpinnerTips, true, 'Gerar Dicas');
            toggleButtonState(generateEssayBtn, buttonTextEssay, loadingSpinnerEssay, true, 'Gerar Redação');
            toggleButtonState(analyzeEssayBtn, buttonTextAnalyze, loadingSpinnerAnalyze, true, 'Analisar Redação');

            essayEditor.value = 'Gerando redação sobre o tema: ' + topic + '...'; // Mensagem de carregamento no editor
            updateWordCount(); // Reseta o contador
            
            // Prompt atualizado para gerar redação no formato ENEM com proposta de intervenção e limite de palavras
            const prompt = `Escreva uma redação completa e original no formato do Exame Nacional do Ensino Médio (ENEM) sobre o tema: '${topic}'. A redação deve ser dissertativa-argumentativa, ter entre 270 e 300 palavras (para simular o espaço da prova), ser bem estruturada em 4 parágrafos (introdução, dois desenvolvimentos robustos e conclusão), e conter uma proposta de intervenção detalhada, visando nota máxima (1000). Use um tom formal e utilize repertórios socioculturais válidos.`;

            await callGeminiApi(prompt, 'essay');
        }
        
        async function analyzeEssay() {
            const essay = essayEditor.value.trim();
            if (!essay) {
                infoContent.innerHTML = '<span class="text-red-500 font-semibold">Por favor, escreva ou gere uma redação para analisá-la.</span>';
                infoContainer.classList.remove('bg-gray-100');
                infoContainer.classList.add('bg-red-100');
                return;
            }
            
            // Desabilita os botões durante a requisição
            toggleButtonState(generateTipsBtn, buttonTextTips, loadingSpinnerTips, true, 'Gerar Dicas');
            toggleButtonState(generateEssayBtn, buttonTextEssay, loadingSpinnerEssay, true, 'Gerar Redação');
            toggleButtonState(analyzeEssayBtn, buttonTextAnalyze, loadingSpinnerAnalyze, true, 'Analisar Redação');
            
            infoContent.textContent = 'Analisando redação. Por favor, aguarde...';
            infoContainer.classList.remove('bg-red-100');
            infoContainer.classList.add('bg-gray-100');

            // Prompt detalhado para análise de redação no formato ENEM, competência por competência
            const prompt = `Você é um corretor especialista do ENEM. Avalie a seguinte redação.
Sua análise deve conter:
1. Uma **nota de 0 a 200** para cada uma das cinco competências do ENEM.
2. Um **resumo dos pontos fortes** da redação.
3. Um **resumo detalhado das sugestões** de melhoria, separadas por competência (C1, C2, C3, C4, C5).
4. Uma **Nota Final** (soma das 5 competências).

Use Markdown para formatar a resposta.

Competências:
C1. Domínio da norma padrão.
C2. Compreensão do tema, formato dissertativo-argumentativo e uso de repertório sociocultural.
C3. Organização e argumentação do ponto de vista.
C4. Conhecimento dos mecanismos linguísticos (conectivos e coesão).
C5. Proposta de intervenção completa.

Redação para análise:
"${essay}"`;

            await callGeminiApi(prompt, 'analysis');
        }

        /**
         * Função principal para chamar a API do Gemini com tratamento de erro e retentativas (Exponential Backoff).
         * @param {string} prompt - O prompt de texto para a API.
         * @param {string} type - O tipo de chamada ('tips', 'essay' ou 'analysis').
         */
        async function callGeminiApi(prompt, type) {
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${API_KEY}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            };

            let retries = 0;
            const maxRetries = 5;

            async function makeApiCall() {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        
                        if (response.status === 429 && retries < maxRetries) {
                            const delay = 1000 * Math.pow(2, retries);
                            // console.log(`Retentando em ${delay}ms...`); // Desativado para aderir ao "Do not log these retries"
                            await new Promise(resolve => setTimeout(resolve, delay));
                            retries++;
                            return makeApiCall(); // Recursão para retentar
                        }
                        
                        throw new Error(`Erro na API (Status: ${response.status}): ${errorData.error?.message || response.statusText || 'Erro desconhecido.'}`);
                    }

                    const result = await response.json();
                    
                    const contentPart = result?.candidates?.[0]?.content?.parts?.[0];
                    if (contentPart?.text) {
                        const text = contentPart.text;
                        if (type === 'essay') {
                            essayEditor.value = text;
                            updateWordCount();
                        } else {
                            infoContent.innerHTML = formatMarkdownToHtml(text);
                        }
                    } else {
                        console.error('Resposta da API está vazia ou malformada:', result);
                        const errorMessage = `Não foi possível ${type === 'essay' ? 'gerar a redação' : 'obter dicas ou análise'}. A resposta da IA está incompleta.`;
                        if (type === 'essay') {
                            essayEditor.value = errorMessage;
                        } else {
                            infoContent.innerHTML = `<span class="text-red-500 font-semibold">${errorMessage}</span>`;
                        }
                    }
                } catch (error) {
                    console.error('Ocorreu um erro na chamada da API:', error);
                    const userErrorMessage = `Erro: Falha ao comunicar com a IA. Verifique se o Canvas está ativo.`;
                    if (type === 'essay') {
                        essayEditor.value = userErrorMessage;
                    } else {
                        infoContent.innerHTML = `<span class="text-red-500 font-semibold">${userErrorMessage}</span>`;
                    }
                } finally {
                    toggleButtonState(generateTipsBtn, buttonTextTips, loadingSpinnerTips, false, 'Gerar Dicas');
                    toggleButtonState(generateEssayBtn, buttonTextEssay, loadingSpinnerEssay, false, 'Gerar Redação');
                    toggleButtonState(analyzeEssayBtn, buttonTextAnalyze, loadingSpinnerAnalyze, false, 'Analisar Redação');
                }
            }
            return makeApiCall();
        }

        // Função para converter o Markdown básico da resposta da IA para HTML
        function formatMarkdownToHtml(markdownText) {
            let html = markdownText;
            
            // Remove quebras de linha que possam interferir na regex de bloco
            html = html.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            // 1. Converte títulos Markdown para HTML
            html = html.replace(/^### (.*$)/gim, '<h3 class="text-xl font-bold mt-4 mb-2 text-gray-800">$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2 class="text-2xl font-bold mt-6 mb-3 text-gray-800">$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1 class="text-3xl font-bold mt-8 mb-4 text-gray-800">$1</h1>');
            
            // 2. Converte listas (antes de parágrafos)
            html = html.replace(/^- (.*$)/gim, '<li class="ml-4 list-disc text-gray-700">$1</li>');
            html = html.replace(/^\* (.*$)/gim, '<li class="ml-4 list-disc text-gray-700">$1</li>');
            html = html.replace(/^(\d+\.) (.*$)/gim, '<li class="ml-4 list-decimal text-gray-700">$2</li>');
            
            // 3. Converte negrito e itálico
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // 4. Adiciona parágrafos para o texto restante
            html = html.split('\n').map(line => {
                const trimmedLine = line.trim();
                // Verifica se a linha não está vazia e não é o início de uma tag de bloco (h1, h2, h3, li, ul, ol, table, p, etc.)
                if (trimmedLine === '' || trimmedLine.startsWith('<h') || trimmedLine.startsWith('<li') || trimmedLine.startsWith('<ul') || trimmedLine.startsWith('<ol') || trimmedLine.startsWith('<p')) {
                    return line;
                }
                return `<p class="mb-2 text-gray-700">${line}</p>`;
            }).join('');

            // Adiciona wrappers para listas (simples, mas funcional)
            html = html.replace(/<li(.*?)<\/li>/gs, (match) => {
                if (!match.startsWith('<ul') && !match.startsWith('<ol')) {
                    return `<ul>${match}</ul>`;
                }
                return match;
            });
            html = html.replace(/<\/ul>\s*<ul>/g, ''); // Junta listas contínuas
            
            return html;
        }
    </script>
</body>
</html>
